#+hugo_base_dir: ../
#+hugo_section: /post/
#+options: author:nil
#+options: ^:nil
#+OPTIONS: tex:t
#+STARTUP: inlineimages
#+ATTR_ORG: :width 500

* ✔ DONE 无题                                                    :misc:@感悟:
CLOSED: [2025-11-08 Sat 21:15]
:PROPERTIES:
:EXPORT_FILE_NAME: wuti
:END:

#+ATTR_ORG: :width 500
#+ATTR_HTML: :width 100% :align center
[[file:~/Documents/RDS/BLOG/hugo/static/img/xiao_chong_shan.jpg]]

----

世人对岳飞的认识，大多来自于他写的《满江红》，“三十功名尘与土，八千里路云和月”，何等荡气回肠，何等波澜壮阔。“待从头，收拾旧河山，朝天阙”，然后风波亭，莫须有，金戈铁马，戛然而止。无论是当时的人，还是后世的我，都唏嘘不已，无语凝噎。但不管如何，这等豪迈的英雄气概，是长留心间的。可对于上面的这首词，很多人就不知晓了，即使读到它，看到作者是岳飞时，都很惊讶，难以置信豪迈的岳飞，也有如此的细腻情感。

我们从小都被告知，岳飞之死，是秦桧诬陷而致。大约二十年前，我读到李亚平的这本书，相当程度地颠覆了我的认知。后来罗胖在刚开始创业时讲《罗辑思维》，里面有一期借鉴了这本书的内容，专门讲岳飞之死。有新意，但给我的震撼就没有这本书那么大了。

#+ATTR_ORG: :width 500
#+ATTR_HTML: :width 30% :align center
[[file:~/Documents/RDS/BLOG/hugo/static/img/diguozhengjiewangshi.jpg]]

----

读了这本书，才真正理解岳飞为什么会写下《小重山》。满腔热血，一心为国，却也不被世人所理解，竟然也不被最高层所信任。所谓功名，所谓利益，所谓盘算，所谓得失，不过是他人茶余饭后的闲聊而已。于当事人，理解也罢、误解也罢，又有何助哉？

上月中旬，不小心得了带状疱疹。开始并没放在心上，医生说疼得很，是否要打进口的针药。我笑着说，无非疼一下，不碍事的。医生继续“吓唬”我，有些人要疼一两年，有些人要疼 3、5 个月，一般至少都要疼 2、3 个月。我挥挥手，无妨，几个月而已。可真正疼起来，我才知道什么是疼 ------ 每天晚上要疼醒 4、5 次啊。到医院再看医生，结束时开了两种药：一是疼得受不了的时候吃的止疼药；一是疼得睡不着的时候吃的安眠药。

半夜起来，独自绕阶行时，脑海里竟然就蹦出岳飞的《小重山》来，虽然是中学时背诵的，但字字清晰，脱口而出，不知是否有感而生。但这次，才真正明白了岳武穆当时的“伤悲”，这无可言说的寂寞。神经之疼、皮肉之痛，哪里比得上内心的痛楚呢？

我好一段时间都疑惑，李商隐写那么多《无题》诗，十分难以理解，为什么不起个名字呢？如今我才明白，有些话，是真找不到名字的。

“刘郎已恨蓬山远，更隔蓬山一万重！”

* ✔ DONE 《深度学习革命》------ 一部波澜壮阔的当代人工智能简史  :reading:@读书:
CLOSED: [2025-10-14 Tue 10:28]
:PROPERTIES:
:EXPORT_FILE_NAME: deep_learning_hisitory
:END:

断断续续，用了两个星期看完了这本关于当代人工智能简介的书。由于人工智能这几年的火爆，类似题材的书已经很多了，但大多数都翻了几页就放下，引不起兴趣。因为这些作者对于人工智能的发展，尤其是深度学习的起起落落，都是人云亦云，没有新意。仿佛深度学习 就是天上掉下来一样，突然就火了。

而被成为深度学习教父的杰弗里·辛顿，为什么突然获得了计算机的最高奖---图灵奖，以及更重要的诺贝尔物理学奖，很多人都一头雾水。在本书里，详细讲述了这个坚持的老头，如 何影响深度学习领域，并影响谷歌这样大公司的 AI 发展。读完之后，就会明白，辛顿作为教父，当之无愧。

世人比较熟知辛顿的学生伊利亚，因为他是如日中天的 OpenAI 公司的创始 CTO。对于另一个学生，阿列克斯，就少有人知晓了。实际上，伊利亚以纯粹技术家闻名，阿列克斯就更是一个只关心技术的“宅男”了。当初深度学习再度被认可，就是师徒三人，打造了一个 Alex-Net，在李飞飞的 ImageNet 识别比赛中，一举夺魁。这里的 Alex，就是阿列克斯的名字。师徒三人创建了一个公司，什么产品都没有，只有三个人，就被谷歌公司以 4400 万美元收购了。不看重具体的产品，只是因为这三个人。

杨立昆在 Meta，约书奥在微软，都深刻影响了这些企业的人工智能发展。书里把脉络梳理得又清楚又有故事性。而哈萨比斯如何创立 DeepMind，并被谷歌收购之后发挥重要作用的内幕，也徐徐道来，读起来津津有味。

这本书中译本有两个缺点：一是人名的翻译实在是别扭，大概译者并不太了解深度学习领域；二是书名实在是不好。现在的名字让人一看就以为是本技术书，但原书名是：Genius Makers: The Mavericks Who Brought AI。这明显是传记类，重点是人啊。尤其这个 Mavericks，简直是神来之笔：标新立异的人，不合常规的人。

深度学习的领导者们，配得上这个称呼。

#+ATTR_ORG: :width 500
#+ATTR_HTML: :width 50% :align center
[[file:~/Documents/RDS/BLOG/hugo/static/img/deep_learning_history.jpg]]

----

很久没有读到这么好的技术传记类书了，好像只有 20 年前，读米歇尔·沃尔德洛普的《复杂：诞生于秩序与混沌边缘的科学》可以比拟。还记得读《复杂》时，心潮澎湃，极其渴望投身到复杂科学研究的队伍里。可惜那时没有胆量，不敢放弃熟悉的研究领域。今天，我很开心，看到了深度学习的前景，更投身进了这个领域。即使没有成功，也不会后悔。

以前在学校时，总觉得自己的研究与社会是脱节的，心里十分惶恐。而真正的研究，是应该要解决实际的问题。

* ✔ DONE 把 Emacs 打造为 Python IDE                          :tech:@技术:
CLOSED: [2025-10-12 Sun 09:10]
:PROPERTIES:
:EXPORT_FILE_NAME: emacs_as_python_IDE
:END:
集成开发环境（IDE）是一种帮助程序员高效开发软件代码的软件应用程序。它通过将软件编辑、构建、测试和打包等功能结合到一个易于使用的应用程序中，提高了开发人员的工作效率。就像作家使用文本编辑器，会计师使用电子表格一样，软件开发人员使用 =IDE= 让他们的工作变得更轻松。当前比较流行的 =Python IDE= 有 =PyCharm=, =IDEA=, =VS CODE= 等。 =Emacs= 作为一个可扩展的文本编辑器，处理各种文本数据是非常方便的。我们在 Emacs 里增加 =elisp= 扩展，就可以模拟各种 =IDE= 的环境，还能更好。

** IDE 的功能
需要模拟的 IDE 基本功能应该包含：
- 代码编辑
- 语法高亮
- 文档查找
- 代码跳转
- 语法解析
- 代码规范
- 代码检查
- 代码调试

** 显示
基本的功能应该有：代码编辑和语法高亮。Emacs 里自带的 python-mode 就可以满足要求。当打开一个 =.py= 结尾的文件时，Emacs 会自动匹配 python-mode 模式。

*** 更好的显示
如果觉得基本的 python-mode 不够，可以用更好的语法解析，然后显示。
#+begin_src emacs-lisp
    (use-package tree-sitter
      :ensure t
      :hook ((python-mode     . tree-sitter-hl-mode)
             (python-ts-mode  . tree-sitter-hl-mode)
            )
    )

    (use-package tree-sitter-langs
      :after tree-sitter 
      :config
      (tree-sitter-require 'python)
    )
#+end_src
有时候 Emacs 升级了之后， =tree-sitter= 版本不匹配，可以手动编译 =tree-sitter-langs= ，然后把编译好的 =dylib= 文件拷贝到 =~/.emacs.d/tree-sitter= 目录下，取名为 =libtree-sitter-python.dylib= 

设置好了之后，语法高亮就比较漂亮了。

#+ATTR_ORG: :width 500
#+ATTR_HTML: :width 60% :align center
[[file:~/Documents/RDS/BLOG/hugo/static/img/tree-sitter.jpg]]

** 文档说明
编程需要时时地查找某个函数的说明、用法等。我们采用 =eldoc= 宏包处理。
#+begin_src emacs-lisp
  (use-package eldoc
    :ensure t
    :defer t
    :init
    (global-eldoc-mode)
  )

  (global-set-key (kbd "C-x c d") 'eldoc-doc-buffer)
#+end_src
当光标放在某个函数/变量上时，用快捷键 =C-x c d= 或者 =M-x eldoc= 就可以显示它的资料
说明---一般就是把函数定义里的说明信息显示出来。 比如，

#+ATTR_ORG: :width 500
#+ATTR_HTML: :width 60% :align center
[[file:~/Documents/RDS/BLOG/hugo/static/img/eldoc.jpg]]

----

*** 更好的文档
=eldoc= 能够识别很多编程语言，既然通用性强，专业性就要稍稍弱一点。因此，我们可以用专门针对 =python= 语言的文档说明---=elpy= 。

#+begin_src emacs-lisp
  (use-package elpy
    :ensure t
    :init
    (elpy-enable)
  )
#+end_src
当按下快捷键 =C-c C-d= 或者 =M-x elpy-doc= 时，就可以在 =elpy= 的 buffer 里显示文档。
比如，
#+ATTR_ORG: :width 500
#+ATTR_HTML: :width 60% :align center
[[file:~/Documents/RDS/BLOG/hugo/static/img/elpy-doc.jpg]]

----

=elpy= 不仅仅是 python 的文档调用，它包含了更多的 python 环境设置（后面我会讲到其他的应用），这里只是显示了它的文档显示功能。

** 语法检查
python 代码是否符合语法，我们可以用专门的检查工具来判断。最常用的有 =flycheck= 和
=flymake= 两种。我倾向于用 +flycheck++ ，还是用 =flymake= 吧，Emacs 30 之后，就完全内
置了，对 =ruff= 的支持也非常好。
#+begin_src emacs-lisp
  (use-package flymake
    :ensure t
    :custom ((flymake-start-on-flymake-mode nil)
             (flymake-no-changes-timeout nil)
             (setq flymake-show-diagnostics-at-end-of-line t)
             (flymake-start-on-save-buffer t)))
#+end_src
如果发现代码里有红色的波浪线显示，就表示发现了语法错误，请尽快修改。

*** 更好的语法检查
=flymake= 默认调用了 =flake8= 或者其他工具来进行语法检查，我们可以把这些工具换成最新最快的工具---- =ruff= 。
#+begin_src emacs-lisp
  ;; 通过 use-package 安装 flymake-ruff
  (use-package flymake-ruff
    :ensure t                
    :hook ((python-mode    . flymake-ruff-load)      ; 传统 python-mode
           (python-ts-mode . flymake-ruff-load))     ; Tree-sitter 版
    :config
    (setq flymake-ruff-program-args '("--quiet" "--output-format=concise"))
    (setq flymake-show-diagnostics-at-end-of-line t) ; 行尾显示
    (setq flymake-no-changes-timeout nil)            ; 实时检查
  )
#+end_src

*** 单独的检查函数
还可以单独定义一个检查函数，方便查看。
#+begin_src emacs-lisp
  ;; 定义ruff-check 修复命令
  (reformatter-define ruff-check
    :program "ruff"
    :args '("check" "--fix" "-")
    :lighter " RuffCheck"
  )

  ; 单独再定义一个检查函数
  (defun ruff-check ()
    (interactive)
    (let ((current-file (buffer-file-name)))
      (if current-file
          (async-shell-command
           (format "ruff check --select ALL %s" (shell-quote-argument current-file))
          )
      )
    )
  )

  ;; 在python mode中，保存时自动运行ruff-format
  (add-hook 'python-mode-hook
            (lambda ()
              (add-hook 'before-save-hook #'ruff-format-region nil t))
  )
#+end_src

=ruff= 需要单独安装，用 =pip= 或者 =brew= 都可以，只要系统的命令行可以找到它就行。

** 代码跳转
在书写/阅读代码时，常常需要从当前使用函数的位置，跳转到函数的定义位置。 =elpy= 就
直接支持这个功能 --- 在函数名的位置处，按下快捷键 =C-c .= 或者 =M-x
elpy-goto-definition= 或者 =M-x elpy-goto-definition-other-window= （在新窗口打开定义文件），就可以跳转到函数的定义，即使定义是在另一个文档里也不要紧，
=elpy= 都自动打开那个文档，把光标放在函数的定义处。

按下 =M-,= ，就可以返回到原来的位置。

*** 更好的跳转
我们可以用 =xref= 实现更好的跳转
- =C-x C-.= or =M-x xref-find-definitins=
- =C-x C-/= or =M-x xref-find-references=
然后用 =C-x C-,= or =M-x xref-pop-marker-stack= or =M-,= 返回原位置。

*** 更全面的跳转
有时候，项目内的模块， =elpy= 和 =xref= 都找不到，我们就自己定义一个函数，功过 =egrep= 来找到函数定义，然后手动打开
#+begin_src emacs-lisp
  (defun elpy-goto-definition-or-rgrep ()
    "Go to the definition of the symbol at point, if found. Otherwise, run `elpy-rgrep-symbol'."
      (interactive)
      (if (version< emacs-version "25.1")
          (ring-insert find-tag-marker-ring (point-marker))
        (xref-push-marker-stack))
      (condition-case nil (elpy-goto-definition)
          (error (elpy-rgrep-symbol
                     (concat "\\(def\\|class\\)\s" (thing-at-point 'symbol) "(")))))

  (define-key elpy-mode-map (kbd "C-c .")     'elpy-goto-definition)
  (define-key elpy-mode-map (kbd "C-c d")     'elpy-goto-definition-or-rgrep)
  (define-key elpy-mode-map (kbd "C-x C-.")   'xref-find-definitions)
  (define-key elpy-mode-map (kbd "C-x C-/")   'xref-find-references)
  (define-key elpy-mode-map (kbd "C-x C-,")   'xref-pop-marker-stack)
#+end_src
当按下 =C-c d= or =M-x elpy-goto-definition-or-rgrep= 时，就会把所有相关的 class 和 def 定义文件都找到。

** 代码补全
程序员通常都很懒，写代码的时候，如果能够只敲一两个字符，系统能够猜出来接下来要写什么就好了，直接按回车键或者 TAB，就把剩下的字符都自动补全了。Emacs 当然也有这样的插件 --- =company= ：complete anything.
#+begin_src emacs-lisp :noweb-ref company-rds
    (use-package company
      :ensure t
      :init
      (add-hook 'c-mode-common-hook 'company-mode)
      (add-hook 'python-mode-common-hook 'company-mode)
      :config
      (eval-after-load 'c-mode '(define-key c-mode-map (kbd "[tab]") 'company-complete))
      (setq company-backends '((company-capf
                               company-keywords
                               company-semantic
                               company-files
                               company-dabbrev
                               company-dabbrev-code
                               company-etags
                               company-clang
                               company-cmake
                               company-yasnippet)))
      (setq company-tooltip-limit 20
            company-tooltip-offset-display 'lines
            company-tooltip-minimum 4
            company-tooltip-flip-when-above t
            company-tooltip-margin 3
            company-tooltip-align-annotations t  ; 对齐注释
            company-tooltip-annotation-padding 1
            company-text-face-extra-attributes '(:weight bold :slant italic)
            company-text-icons-add-background t
            company-echo-delay 0
            company-require-match nil
            company-minimum-prefix-length 1      ; 只需敲 1 个字母就开始进行自动补全
            company-show-numbers t               ; 给选项编号 (按快捷键 M-1、M-2 等等来进行选择).
            company-dabbrev-other-buffers t
            company-dabbrev-ignore-case 'keep-prefix
            company-selection-wrap-around t
            company-show-quick-access 'left
            company-idle-delay 0
            company-tooltip-idle-delay 10
            company-require-match nil
            company-frontends '(company-pseudo-tooltip-unless-just-one-frontend-with-delay
                                company-preview-frontend
                                company-echo-metadata-frontend)
            company-backends '(company-capf)
            company-files-exclusions '(".git/" ".DS_Store")
      )
      (global-company-mode 1)
    )
#+end_src
可以看出， =company= 能识别很多种语言，python 当然也支持了。

** LSP
LSP 是 Language Server Protocol 的缩写，该协议被用在编辑器或 IDE 与语言服务器之间，为编辑器提供自动补全，跳转到定义和引用查找等功能。以下内容来自 LSP 官网：

#+begin_quote
Adding features like auto complete, go to definition, or documentation on hover for a programming language takes significant effort. Traditionally this work had to be repeated for each development tool, as each tool provides different APIs for implementing the same feature.

A Language Server is meant to provide the language-specific smarts and communicate with development tools over a protocol that enables inter-process communication.

The idea behind the Language Server Protocol (LSP) is to standardize the protocol for how such servers and development tools communicate. This way, a single Language Server can be re-used in multiple development tools, which in turn can support multiple languages with minimal effort.

为一种编程语言添加自动补全，跳转到定义或悬停文档等功能需要很大的努力。在过去需要为每个开发工具重复这项工作，因为每个工具都提供不同的 API 来实现相同的功能。

语言服务器旨在提供特定语言的功能，并通过支持进程间通信的协议与开发工具进行通信。

语言服务协议（LSP）背后的想法是对此类服务器和开发工具如何通信的协议进行标准化。这样，单个语言服务器可以在多个开发工具中重复使用，从而可以以最小的努力支持多种语言。
#+end_quote

这样，我们只需在 Emacs 里设置一个客户端，用来对接外部的 python 语言服务器程序，充分利用服务器的所有功能即可。

*** 服务器
当前支持 python 最好的语法解析工具是微软开发的 =pyright= ，以及它的分支
=basedpyright= 。基本用法是一样的，后者支持更多的功能。它们都可以通过 =pip= 或者
=brew= 单独安装。

*** 客户端
Emacs 里最流行的 LSP 客户端有三个：
- lsp-mode （不要与 LSP 服务器混淆了）
- eglot
- lsp-bridge

其中，Emacs 内置了 Eglot，所以最轻量级，但基本满足了需求。除非有特殊的要求，不要轻易使用 lsp-mode，它启动太慢了。

*** 配置
#+begin_src emacs-lisp
  (use-package eglot
    :ensure t
    :defer t
    :bind (:map eglot-mode-map
                ("C-c C-d" . elpy-doc)
                ("C-c C-e" . eglot-rename)
                ("C-c C-o" . python-sort-imports)
                ("C-c C-f" . eglot-format-buffer))
    :hook ((python-mode . eglot-ensure)
           (python-mode . flyspell-prog-mode)
           (python-mode . superword-mode)
           (python-mode . hs-minor-mode)
           (python-mode . (lambda () (set-fill-column 88))))
    :config
    ;; 用basedpyright替换默认pylsp
    ;; 它会提供补全、跳转定义等功能，但诊断信息交给 flycheck
    (add-to-list 'eglot-server-programs
                 '(python-mode     . ("basedpyright-langserver" "--stdio"))
    )
    ;; 关闭 pyright 的 linting，由 ruff 处理
    (setq eglot-workspace-configuration
          '((:python (:analysis (:typeCheckingMode . "basic")
                                (:lintingMode . "off")
                                (:reportMissingImports . true)))))
    (setq eglot-ignored-server-capabilities
        '(:diagnosticProvider))    ; 只让 Flymake 报告 lint

    ;; 日志级别（调试时用 'debug'，日常用 'warning'）
    (setq eglot-log-level 'warning)
    :init
    (setq completion-category-overrides
          '((eglot (styles orderless))))
  )

  ;; 保存时自动格式化（使用 eglot 内建格式化）
  (add-hook 'python-mode-hook
            (lambda ()
              (add-hook 'before-save-hook 'eglot-format-buffer nil t))
  )

  ;; 启动成功提示
  (add-hook 'eglot-managed-mode-hook
            (lambda ()
              (message "[EGLOT] Connected to basedpyright"))
  )

#+end_src
可以看出，eglot 帮助 Emacs 对接了很多外部服务： =basedpyrigh, elpy, flyspell=,
......。它接受 =basedpyright= 等处理 python 代码后发来的信息，然后交给相应的工具去
处理， =eglot= 再最后统一显示出来。比如，我们可以在调用 =flymake= 进行语法检查，
#+begin_src emacs-lisp
  (add-hook 'eglot-managed-mode-hook #'flymake-ruff-load)   
#+end_src

** 代码格式化
很多人写 python 代码，都不是很规范。由于 python 对格式有比较强的要求，不像 C/C++ 语言是自由格式。所以，我们可以用专门的工具来规范化代码。这里，仍然可以用 =ruff= 来完成此功能。
#+begin_src emacs-lisp
  (use-package ruff-format
    :ensure t
    :after (flymake ruff)
  )

  (use-package reformatter
    :ensure t
    :hook
    (python-mode    . ruff-format-on-save-mode)
    (python-ts-mode . ruff-format-on-save-mode)
    :config
    ;; 定义ruff-format格式化命令
    (reformatter-define ruff-format
      :program "ruff"
      :args '("format" "--stdin-filename", buffer-file-name "-")
      :lighter " UrffFmt"
    )
  )

  (defcustom ruff-format-import-command "ruff"
    "Ruff command to use for formatting."
    :type 'string
    :group 'ruff-format-import)

  ;;;###autoload (autoload 'ruff-format-import-buffer "ruff-format-import" nil t)
  ;;;###autoload (autoload 'ruff-format-import-region "ruff-format-import" nil t)
  ;;;###autoload (autoload 'ruff-format-import-on-save-mode "ruff-format-import" nil t)
  (reformatter-define ruff-format-import
    :program ruff-format-import-command
    :args (list "check" "--fix" "--select=I" "--stdin-filename" (or (buffer-file-name) input-file))
    :lighter " RuffFmt"
    :group 'ruff-format-import)
#+end_src

文件保存时，代码会自动被格式化。

至此，我们已经打造了一个漂亮好用的 Python IDE。Enjoy it.

* ✔ DONE 一个概率事件的启发                                  :thinking:@思维:
CLOSED: [2025-03-10 Mon 09:32]
:PROPERTIES:
:EXPORT_FILE_NAME: probability_thingking
:END:
我们从中学开始，就学了概率和统计，但是大多数人都被那些绕来绕去的数学题搞得头昏脑胀，完全不知道这些思想在现实中有什么用处。其实，日常生活中，大量的事情都是由概率和统计来支撑的。脑袋里如果没有这个思想，就很容易犯错误，甚至被骗。我用一个例子来说明一下。

** 事例
如果社会上突然出现一种传染病，很致命，大概被传染变成阳性的概率是千分之一。大家都很担心，也希望早早地发现并预防。于是，科学家研制出了一种检测仪器，运用了最先进的科学技术，检测成功率为 99.9%。只要被感染，就能及时地检测出来。但是，大家都知道，任何仪器都有一定的出错概率，也就是误检率 ------ 一个人没有被感染，但是被检测为阳性，俗称“假阳性”。科学家们又想了很多办法，最后也运用了最先进的科学技术，让误检率也变得很低，最后的效果也是 99.9%的可能不会出现“假阳性”。

现在，如果一个人被这台仪器检测为阳性了，请问，他真正被感染的概率是多大？

** 暂停
请大家暂停往下读，自己猜一下正确答案。

------

...

...

** 答案
很多人都觉得，这个仪器这么先进，检测成功率为 99.9%，误检率也很低，那一旦被检测出来是阳性，至少也是 80%以上的可能性被感染了吧。于是吓得不行。但真实的答案是：只有 50%的可能性是阳性。

我来解释一下，由于这个病的发病率是千分之一，可以假定 1000 个人里，有一个人是真正阳性的。这台仪器的检测正确率是 99.9%，因此这个阳性的人，一定会被检测出来。但是，虽然仪器的误检率也很低，但是也会把正常的人检测出是阳性。这个概率是多少呢？99.9%意味着，1000 个人中也有一个正常人会被检测为“假阳性”。于是，在这 1000 个人中，就有两个人会被仪器检测为阳性，但只有一个人是真被感染者。

所以，如果仪器说一个人是阳性，意味着，他/她只有一半的可能是真正的被感染者。

** 解释
为什么答案和直觉相差这么大呢？奥秘就在于这个病的真实发病率，只有千分之一。也就是说，这个病的犯病率是小概率事件。我们大家对于小概率没有直观的感受和认识，于是现实生活中，遇到这种情况，就会慌了手脚，觉得这么先进的仪器，都检测出来是阳性了，还能是假的？很多骗子于是就趁虚而入，大发其财了。

所以，卡尔·萨根说过一句名言：Extraordinary claims require extraordinary evidence ------ 超凡主张须有超凡证据。一件事，如果发生的概率很小，我们如果要下结论，就必须格外慎重，需要更多的证据来支撑才行。

** 引申
因此，对于大概率事件和小概率事件，大家一定要有一定的认知。在上面的例子中，如果发病率是万分之一，大家可以算算，即使这么先进的仪器检测出来是阳性，真实的得病概率是多大？

万分之一的发病率，对于真实世界来说，是很常见的。大多数的疑难杂症，都远远低于这个概率。所以，现实生活中，一定不要迷信哪一家机构的诊断结果，不是说他们水平不高，而是数学就证明了，多做几次检测，才是最重要的。

* ✔ DONE 一个奇妙的数学思维                                :thinking:@思维:
CLOSED: [2025-03-07 Fri 11:14]
:PROPERTIES:
:EXPORT_FILE_NAME: math_thingking
:END:
数学真是一个奇怪的东西，我们早就知道了各种美妙的数学思想，以及抽象美带来的震撼。前两天，我看到一个关于数学命题证明的小故事，再一次地刷新了我对于数学思想的认识。

我们都知道，数学证明中有一种方法叫反证法，就是通过是否能找出一个反例，来证明一个命题的正确性。但是，这次说的是，我们找不到反例，但依然能够用反证法来证明一个命题。我简单地描述一下这个命题，然后用我自己理解的方式来讲述一下这个证明过程（如果证明错了，责任全在我，原来的数学思想应该是正确的 😉）

** 命题
请判断并证明：一个无理数的无理数次幂，一定是无理数。

** 解释
无理数就是无限不循环小数，比如 $\pi$, $e$, ......, 等等。由于无理数无法精确得到所有数值，所以一个无理数的无理数次幂，除了少数情况外，是无法准确得到所有数值的。比如，$\pi^{\pi}$，它的前 30 位数值是：36.4621596072079117709908260227。我们根本无法从中判断，最后的数值是否是一个有理数，还是仍然为无理数。

** 证明
我们用反证法来证明此命题，即假设原命题是成立的。

首先，我们构造一个无理数的无理数次幂： $x = \sqrt{2}^{\sqrt{2}}$, 这个数值有两种情况：
1. $x$ 为有理数
2. $x$ 为无理数

对于结果 1，那命题当然就错了，因为我们找到了一个无理数的无理数次幂为有理数。我们用反证法来判断情况 2，我们继续构造一个新的数： $y = x^{\sqrt{2}}$, 运算可得：

\(y = \sqrt{2}^{\sqrt{2}^{\sqrt{2}}} = \sqrt{2}^2 = 2 \)

由于 $x$ 为无理数，根据假设，$y$ 也应该是无理数，但现在我们得到了一个有理数 $2$，所以假设不成立，结论应该是，无理数的无理数次幂，不一定是无理数。

** 说明
这里，最奇妙的就是，我们虽然构造了一个无理数的无理数次幂：\(\sqrt{2}^{\sqrt{2} }\)，但是我们并没有实际求出来这个数，也完全没有证明，这个数到底是无理数还是有理数。也就是说，我们用了反证法，但是并没有实际找到一个反例，就证明了原来的命题不成立。

啊，多么奇妙的数学思想啊。

** P.S.
大家可能有点好奇，到底 \(\sqrt{2}^{\sqrt{2} }\) 是不是有理数啊。我用心爱的 Wolfram 计算了一下前 1000 位数值，你们猜，它到底是不是有理数？😜

\(\sqrt{2}^{\sqrt{2}  
} = \) 

1.632526919438152844773495381024719602079108857053
   11411724778068438303520599861664224785550750662
   60414230011620076508762926586855535678286653743
   53276990370339509808349458727844365578417316013
   87397734571771945017640579176808540612696970706
   77170888211473865443716121182725324216022231689
   35434603655006804958808606092092531292648747441
   39100350665100223159724526414595020972636096696
   48057571699115982318026242029527507671359747631
   50951814992616526918951905735917879441942227750
   48361947119473707135051457034779869040074304850
   86049086756447969815057362491879184271662118777
   21616761344994650906881387122735130101636571052
   64559906025136865172262615799791196913108286037
   30870686736120983480646071979524565988415556211
   89979103761174458226636201867544028322841005469
   75220327810489296271028397543501936633946445408
   54828542034506598152799747777276307577783001254
   46163190919411727134856477923053227331124570871
   94322830350968985979373357020305196153528119081
   54595746674092743048895923198652644685232660662
   62013475716

* ✔ DONE 《一个村庄里的中国》------ 改革，改变了什么          :reading:@读书:
CLOSED: [2025-02-16 Sun 21:28]
:PROPERTIES:
:EXPORT_FILE_NAME: china_in_village
:END:

这本书在我的书库里放了很久，都没有翻开来读。一是太厚重，二来也太沉重。但心里一直记挂着它，于是借这次来北京办事，路途和晚上，没有其他什么事，也就排除干扰，认真读完。果然如自己所料，读完之后，沉重的部分更加沉重，而当年迷茫之处，似乎也没有开悟多少。

#+ATTR_ORG: :width 500
#+ATTR_HTML: :width 60% :align center
[[file:~/Documents/RDS/BLOG/hugo/static/img/china_in_village.jpg]]

----

《一个村庄里的中国》以作者熊培云从小生活的小堡村为例，讲述了一个村庄近百年的变迁，进而引伸出国家的变化。中国几千年来都是一个农业国家，虽然近 30 年，随着世界潮流的进步，也大大加快了现代化的进程。但各种社会现象，以及出现的很多社会问题，本质上都与农村、农业和农民息息相关。我博士毕业的 2001 年前后，曾经社会上很热烈地讨论“三农”问题。当时，一个年轻的乡党委书记---李昌平，给总理写了封信，大声呼吁：农民真苦、农村真穷、农业真危险！引起了社会极大的反响，高层也开始认真对待“三农”。我当时读了很多相关的书籍和文章，和志刚、唐博士都不止一次激烈争辩过类似话题，那就是，农民的问题，到底是个人因素多还是国家因素重？

封建帝王时代，自不必说，农民只是维系社会运转的零件而已。“草民”、“蚁民”、“贱民”等称呼，有自嘲的，有被强加的。但对于统治者来说，大约农民和一棵草、一只蚂蚁，真不会有多大区别。到了民国时代，从上层到社会中坚，很多人开始反思，如果农民不富足不开化，国家怎么称得上发达？国家又如何与列强抗衡？上个世纪二十年代开始的各种改革，有官方的，有自发的，有热血人士主动深入农村试验的......，不一而足。但结果毫无例外，自然都是失败了。

因为土改，吸引了更多农村子弟参与革命。到了胜利，又回到农村。曾经的土地流转，最后又复归原点。底层的人民，似乎什么都没有拥有过，而有些人，却上下其手，城乡通吃，两面的利益都获取了。如今的乡村，青壮年流失严重，老少两极留守，诸多问题，基本是靠个体和家庭来消化。经济高速发展的时候，城市还可以带动农村。等到经济减缓或者停滞时，城市还需要农村来反哺。而克强总理曾经公开的数据 ------ 6 亿人口，月收入低于千元 ------ 如何平衡呢？

一个村庄的百年变迁，似乎也没有逃过多少轮回的命运。村庄里看出的国家，又有多少人的命运，在时代的潮流中反复轮回？

我虽然是油田出生的孩子，但从小钻井公司的大院围墙外，都是农村。我也喜欢一个人，经常翻出围墙，到田野里疯跑。经常跑累了，就静静地坐在田间地头，和农民聊天。或者，就抱膝席地而坐，看天上的白云散了又聚，聚了又散。父亲也经常给我讲小时候在农村的各种苦日子，家族曾经发达过，但在爷爷小时候，他的父亲早逝，于是家道中落，孤儿寡母，和大多人农人一样，苦苦维持着生计。父亲兄弟姊妹六人，也只有他读书考学离开了农村。于是，《一个村庄里的中国》里描述的小堡村，我读起来仿佛就很熟悉，很像父亲从小生活的地方，而里面的人，大约也像我的爷爷们。

还在本科时，我就读过教员写的《湖南农民运动考察报告》、《论十大关系》等文章。当时模模糊糊，并不真切地明白里面的很多含义。如今，自己感受过更多的社会百态，也有了一些感悟。可是，真实世界里的很多朋友，似乎在城里待久了，或者从未感触过农村的具体生活，常常觉得我在夸张。我想，大家如果都来读读《一个村庄里的中国》，感受一下真实的农村，同理心和社会心大概都会好很多。在这个世界里，大家的悲欢，并不相同。倘若能相通一些，也许能少许多争吵。

我总怀疑熊培云和我是一个年代的人，检索之后，果不其然。书斋里象牙塔中的知识分子啊，也要多写一些这样的文章才好，多读一些这样的文章才好。

